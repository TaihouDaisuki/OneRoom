#include "server.h"

using namespace std;

void reset_daemon();

int main()
{
    reset_daemon();

    while(TAIHOUDAISUKI)
    {
        ServerSock *server = new (nothrow) ServerSock;
        if (server == NULL)
        {
            cerr << "Server Initial Error" << endl;
            return -1;
        }

        server->Server_Start();
        cout << "Server has stopped running" << endl;
        delete server;

        sleep(1);
    }
    
    return 0;
}

void reset_daemon()
{
	pid_t pid;
	if((pid = fork()))
		exit(0);	//是父进程，则结束父进程
	else if(pid < 0)
		exit(1);	//fork失败，退出
	
	//是第一子进程，后台继续执行
	setsid();		//第一子进程成为新的会话组长和进程组长
	//与控制终端分离
	if((pid = fork()))
		exit(0);	//是第一子进程，结束第一子进程
	else if(pid < 0)
		exit(1);	//fork失败，退出
	//是第二子进程，继续。第二子进程不再是会话组长
	
	//for(i = 0; i < NOFILE; ++i)
	//	close(i);
		//关闭从父进程继承打开的文件描述符，节省系统资源
		//但这里需要输出回显，因此不关闭

	//chdir("/root/");	//改变工作目录到root，这里只需要打印，所以不需要
	umask(0);			//重设文件创建掩模，防止守护进程创建的文件存取位被父进程修改
	return;
}
